#include <stdio.h>
#include <vector>
#include <map>
#include <algorithm>
using namespace std;
#define MAX 1000000000

int N, M, sz;
vector<int> prime;
bool composite[32000];
map<int, int> A_map, B_map;

void get_prime() {
	for (int i = 2; i < 32000; i++) {
		if (composite[i]) continue;
		prime.push_back(i);
		for (int j = 2 * i; j < 3200; j = j + i)
			composite[j] = true;
	}
}

int main() {

	get_prime();
	sz = prime.size();

	int num;
	scanf("%d", &N);
	for (int i = 0; i < N; i++) {
		scanf("%d", &num);
		for (int j = 0; j < sz && prime[j] <= num; j++) {
			while (num % prime[j] == 0) {
				A_map[prime[j]]++;
				num /= prime[j];
			}
		}
		if (num > 1) A_map[num]++;
	}

	scanf("%d", &M);
	for (int i = 0; i < M; i++) {
		scanf("%d", &num);
		for (int j = 0; j < sz && prime[j] <= num; j++) {
			while (num % prime[j] == 0) {
				B_map[prime[j]]++;
				num /= prime[j];
			}
		}
		if (num > 1) B_map[num]++;
	}

	bool flag = false;
	long long ans = 1;
	map<int, int> ::iterator A_it = A_map.begin(), B_it = B_map.begin();
	while (A_it != A_map.end() && B_it != B_map.end()) {
		int A_prime = A_it->first;
		int B_prime = B_it->first;
		if (A_prime < B_prime) A_it++;
		else if (A_prime > B_prime) B_it++;
		else {
			int n = min(A_it->second, B_it->second);
			while (n--) {
				ans = ans * A_it->first;
				if (ans > MAX) {
					flag = true;
					ans %= MAX;
				}
			}
			A_it++; B_it++;
		}
	}

	if (flag) {
		char buf[10];
		for (int i = 8; i >= 0; i--) {
			buf[i] = (ans % 10) + '0';
			ans /= 10;
		}
		buf[9] = '\0';
		printf("%s", buf);
	}
	else printf("%lld", ans);
	return 0;
}
